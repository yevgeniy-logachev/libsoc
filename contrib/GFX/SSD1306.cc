/*********************************************************************
This is a library for our Monochrome OLEDs based on SSD1306 drivers

  Pick one up today in the adafruit shop!
  ------> http://www.adafruit.com/category/63_98

These displays use SPI to communicate, 4 or 5 pins are required to  
interface

Adafruit invests time and resources providing this open source code, 
please support Adafruit and open-source hardware by purchasing 
products from Adafruit!

Written by Limor Fried/Ladyada  for Adafruit Industries.  
Subsequent modifications by J. Bergeron <janick@bergeron.com>
  - Refactored driver into a Strategy Pattern
  - Port to BoneLib
  - Port to libsoc

BSD license, check license.txt for more information
All text above, and the splash screen must be included in any redistribution
*********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "SSD1306.hh"

using namespace libSOC;
using namespace RGB;


#define SSD1306_SETCONTRAST         0x81
#define SSD1306_DISPLAYALLON_RESUME 0xA4
#define SSD1306_DISPLAYALLON        0xA5
#define SSD1306_NORMALDISPLAY       0xA6
#define SSD1306_INVERTDISPLAY       0xA7
#define SSD1306_DISPLAYOFF          0xAE
#define SSD1306_DISPLAYON           0xAF

#define SSD1306_SETDISPLAYOFFSET    0xD3
#define SSD1306_SETCOMPINS          0xDA

#define SSD1306_SETVCOMDETECT       0xDB

#define SSD1306_SETDISPLAYCLOCKDIV  0xD5
#define SSD1306_SETPRECHARGE        0xD9

#define SSD1306_SETMULTIPLEX        0xA8

#define SSD1306_SETSTARTLINE        0x40
#define SSD1306_SETLOWCOLUMN        0x00
#define SSD1306_SETHIGHCOLUMN       0x10

#define SSD1306_MEMORYMODE          0x20

#define SSD1306_COMSCANINC          0xC0
#define SSD1306_COMSCANDEC          0xC8

#define SSD1306_SEGREMAP            0xA0

#define SSD1306_CHARGEPUMP          0x8D

// Scrolling #defines
#define SSD1306_ACTIVATE_SCROLL                      0x2F
#define SSD1306_DEACTIVATE_SCROLL                    0x2E
#define SSD1306_SET_VERTICAL_SCROLL_AREA             0xA3
#define SSD1306_RIGHT_HORIZONTAL_SCROLL              0x26
#define SSD1306_LEFT_HORIZONTAL_SCROLL               0x27
#define SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL 0x29
#define SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL  0x2A

#define _BV(x) (1<<(x))

// the memory buffer for the LCD, in horizontal addressing order
static uint8_t buffer[SSD1306::WIDTH * SSD1306::HEIGHT / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// reduces how much is refreshed, which speeds it up!
// originally derived from Steve Evans/JCW's mod but cleaned up and
// optimized
#define enablePartialUpdate
#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif

static void updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
  if (xmin < xUpdateMin) xUpdateMin = xmin;
  if (xmax > xUpdateMax) xUpdateMax = xmax;
  if (ymin < yUpdateMin) yUpdateMin = ymin;
  if (ymax > yUpdateMax) yUpdateMax = ymax;
#endif
}

SSD1306::SSD1306(gpio* sclk, gpio* din, gpio* dc, gpio* cs, gpio* rst, unsigned char height)
  : m_spi(NULL), m_din(din), m_sclk(sclk), m_dc(dc),
    m_rst(rst), m_cs(cs), m_height(height)
{
  if (height != 32 && height != 64) {
    fprintf(stderr, "ERROR: Height of SSD1306 OLED must be 32 or 64\n");
    exit(1);
  }

  // set pin directions
  if (m_sclk == NULL) {
    fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::sclk.\n");
    exit(1);
  }
  m_sclk->makeOutput();

  if (m_din == NULL) {
    fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::din.\n");
    exit(1);
  }
  m_din->makeOutput();
  
  if (m_dc == NULL) {
    fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::d/c.\n");
    exit(1);
  }
  m_dc->makeOutput();

  if (m_cs != NULL) m_cs->makeOutput();
  if (m_rst != NULL) m_rst->makeOutput();
}


SSD1306::SSD1306(spi *spiDev, gpio* dc, gpio* rst, unsigned char height)
  : m_spi(spiDev), m_din(NULL), m_sclk(NULL), m_dc(dc),
    m_rst(rst), m_cs(NULL), m_height(height)
{
  if (height != 32 && height != 64) {
    fprintf(stderr, "ERROR: Height of SSD1306 OLED must be 32 or 64\n");
    exit(1);
  }

  if (m_spi == NULL) {
    fprintf(stderr, "ERROR: Bad SPI interface/device specified for SSD1306::spi.\n");
    exit(1);
  }

  // set pin directions
  if (m_dc == NULL) {
    fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::d/c.\n");
    exit(1);
  }
  m_dc->makeOutput();

  if (m_rst != NULL) m_rst->makeOutput();
}


/** Reset the display */
void
SSD1306::reset(void)
{
  if (m_sclk != NULL) m_sclk->setValue(1);
  if (m_cs != NULL) m_cs->setValue(1);
  if (m_rst == NULL) return;
  // toggle RST low to reset
  m_rst->setValue(0);
  m_rst->setValue(1);
}

/** Clear the display */
void
SSD1306::clear(void)
{
  memset(buffer, 0x00, getWidth()*m_height/8);
  updateBoundingBox(0, 0, getWidth()-1, m_height-1);
}

/** Refresh the display */
void
SSD1306::refresh(void) {
  if (m_cs != NULL) m_cs->setValue(0);

#ifdef enablePartialUpdate

  unsigned int minRow = yUpdateMin/8;
  unsigned int maxRow = yUpdateMax/8;
  command(0x22);   // Set page start/end addresses
  command(minRow);
  command(maxRow);

  unsigned int minCol = xUpdateMin;
  unsigned int maxCol = xUpdateMax;
  command(0x21);                                  // Set column start/end addresses
  command(minCol);
  command(maxCol);

  m_dc->setValue(1);
  for(int row = minRow; row <= maxRow; row++) {
    for(int col = minCol; col <= maxCol; col++) {
      SPIwrite(buffer[(getWidth()*row)+col]);
    }
  }

  xUpdateMin = getWidth() - 1;
  xUpdateMax = 0;
  yUpdateMin = getHeight() - 1;
  yUpdateMax = 0;

#else

  command(0x21);                                  // Set column start/end addresses
  command(0x00);                                  // Start == 0
  command(0x7F);                                  // End = 127
  command(0x22);                                  // Set page start/end addresses
  command(0x00);                                  // Start == 0
  command(getHeight()/8-1);                      // End == #rows/8


  m_dc->setValue(1);
  for (int i = 0; i < getHeight()*getWidth()/8; i++) {
    SPIwrite(buffer[i]);
  }

#endif

  if (m_cs != NULL) m_cs->setValue(1);
}

/** Return the width of the display, in pixels */
uint16_t
SSD1306::getWidth(void)
{
  return WIDTH;
}

/** Return the height of the display, in pixels */
uint16_t
SSD1306::getHeight(void)
{
  return m_height;
}

/** Set a color pixel */
void
SSD1306::drawPixel(int16_t x, int16_t y, rgb_t color)
{
  if ((x < 0) || (x >= getWidth()) || (y < 0) || (y >= getHeight()))
    return;

  uint8_t shade = (color.red + color.green + color.blue) / 3;

  // x is which column
  if (shade < 128)
    buffer[x + (y/8)*getWidth()] |= _BV(y%8);  
  else
    buffer[x + (y/8)*getWidth()] &= ~_BV(y%8); 

  updateBoundingBox(x,y,x,y);
}

/* Get the color of a pixel */
rgb_t
SSD1306::getPixel(int16_t x, int16_t y)
{
  if ((x < 0) || (x >= getWidth()) || (y < 0) || (y >= getHeight()))
    return RGB::black;

  if ((buffer[x + (y/8)*getWidth()] >> (7-(y%8))) & 0x1) return RGB::black;
  return RGB::white;
}

void
SSD1306::begin()
{
  reset();

  if (m_cs != NULL) m_cs->setValue(0);

  command(SSD1306_DISPLAYOFF);                    // 0xAE
  command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
  command(0x80);                                  // the suggested ratio 0x80
  command(SSD1306_SETMULTIPLEX);                  // 0xA8
  if (getHeight() == 32) {
    command(0x1F);
  } else {
    command(0x3F);
  }
  command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
  command(0x00);                                  // no offset
  command(SSD1306_SETSTARTLINE | 0x00);           // line #0
  command(SSD1306_CHARGEPUMP);                    // 0x8D
  command(0x14);
  command(SSD1306_MEMORYMODE);                    // 0x20
  command(0x00);                                  // Horizontal
  command(SSD1306_SEGREMAP | 0x01);               // SEG0 is column 127
  command(SSD1306_COMSCANDEC);                    // Scan from COM[N-1] to 0
  command(SSD1306_SETCOMPINS);                    // 0xDA
  if (getHeight() == 32) {
    command(0x02);
  }
  else {
    command(0x12);
  }
  command(SSD1306_SETCONTRAST);                   // 0x81
  if (getHeight() == 32) {
    command(0x8F);
  }
  else {
    command(0xCF);
  }
  command(SSD1306_SETPRECHARGE);                  // 0xd9
  command(0xF1);
  command(SSD1306_SETVCOMDETECT);                 // 0xDB
  command(0x40);
  command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
  command(SSD1306_NORMALDISPLAY);                 // 0xA6

  command(SSD1306_DISPLAYON);//--turn on oled panel

  // Refresh the screen (will display the AFI logo)
  updateBoundingBox(0, 0, getWidth()-1, m_height-1);
  refresh();
}


void
SSD1306::command(uint8_t c)
{
  m_dc->setValue(0);
  SPIwrite(c);
}

void
SSD1306::data(uint8_t c)
{
  m_dc->setValue(1);
  if (m_cs != NULL) m_cs->setValue(0);
  SPIwrite(c);
  if (m_cs != NULL) m_cs->setValue(1);
}

inline void
SSD1306::SPIwrite(uint8_t d)
{
  if (m_spi != NULL) {
    m_spi->send(1, (const char*) &d);
    return;
  }

  for(uint8_t bit = 0x80; bit; bit >>= 1) {
    m_din->setValue((d & bit) ? 1 : 0);
    m_sclk->setValue(0);
    m_sclk->setValue(1);
  }
}


bool
SSD1306::saveScreen(const char* fname)
{
  FILE *fp = fopen(fname, "w");
  if (fp == NULL) {
    fprintf(stderr, "ERROR: Cannot save screen to file \"%s\": ", fname);
    perror(0);
    return false;
  }

  fprintf(fp, "static uint8_t buffer[SSD1306::WIDTH * SSD1306::HEIGHT / 8] = {\n");
  for (int i = 0; i < sizeof(buffer); i++) {
    if (i % 16 == 0) fprintf(fp, "   ");
    fprintf(fp, "0x%02x, ", buffer[i]);
    if (i % 16 == 15) fprintf(fp, "\n");
  }
  fprintf(fp, "};\n");
  fclose(fp);

  return true;
}


#ifdef TEST

#include <libsoc/debug.hh>


int
main(int argc, const char* argv[])
{
  libSOC::debug::set_level(0);
  
  //#define SPI
#ifdef SPI
  libSOC::SSD1306 drv(libSOC::spi::get(32766, 0), // SPI
		      libSOC::gpio::get("CSID1"),  // D/C
		      libSOC::gpio::get("CSID0"),  // RST
		      64);
#else
  libSOC::SSD1306 drv(libSOC::gpio::get("CSID4"),     // CLK
		      libSOC::gpio::get("CSID6"),  // DIN
		      libSOC::gpio::get("CSID1"),     // D/C
		      libSOC::gpio::get("CSID2"),    // CS
		      libSOC::gpio::get("CSID0"),    // RST
		      64);
#endif

  int X = drv.getWidth();
  int Y = drv.getHeight();

  int max = (X > Y) ? X : Y;

  float x, y;
  float dx = (X * 1.0) / max;
  float dy = (Y * 1.0) / max;


  printf("Starting test...\n");

  drv.begin();
  printf("Note: The Adafruit splash screen should be displayed on the screen...\n");
  sleep(2);

  drv.clear();
  drv.refresh();
  printf("Note: The screen should have been cleared...\n");
  sleep(2);

  // Draw a 'X' across the display
  for (x = 0, y = 0; x < X; x += dx, y += dy) {
    drv.drawPixel((int)x, (int)y, libSOC::RGB::black);
    drv.drawPixel((int)(drv.getWidth() - x), (int)y, libSOC::RGB::black);
  }
  drv.refresh();
  printf("Note: There should be a large 'X' across the screen...\n");
  sleep(2);


  // Flash a medium square in the middle
  libSOC::RGB::rgb_t color;

  X = drv.getWidth() / 2 - 10;
  Y = drv.getHeight() / 2 - 10;
  for (int i = 0; i < 11; i++) {
    color = (i%2) ? libSOC::RGB::white : libSOC::RGB::black;
    for (x = 0; x < 20; x++) {
      for (y = 0; y < 20; y++) {
	drv.drawPixel(X+x, Y+y, color);
      }
    }
    drv.refresh();
  }

  // Flash a smaller square in the middle
  X = drv.getWidth() / 2 - 4;
  Y = drv.getHeight() / 2 - 4;
  for (int i = 0; i < 10; i++) {
    color = (i%2) ? libSOC::RGB::white : libSOC::RGB::black;
    for (x = 0; x < 8; x++) {
      for (y = 0; y < 8; y++) {
	drv.drawPixel(X+x, Y+y, color);
      }
    }
    drv.refresh();
  }
  sleep(1);

  drv.reset();

  printf("Done!\n");
  return 0;
}
#endif
